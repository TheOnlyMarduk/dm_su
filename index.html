<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<title>Laufstrecken mit Informationen-Layer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>

<style>
  html, body { margin: 0; padding: 0; height: 100%; }
  #map { height: 100vh; width: 100vw; }
  .marker-label {
    background: white;
    border: 2px solid black;
    border-radius: 50%;
    text-align: center;
    font-weight: bold;
    color: black;
    box-shadow: 0 0 3px rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
  }
</style>
</head>
<body>
<div id="map"></div>

<script>
const map = L.map('map').setView([50.94, 6.96], 13); // Startposition Köln

// OpenStreetMap-Kachel-Layer
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '© OpenStreetMap'
}).addTo(map);

// Beispiel Layergruppen (wie in deinem Code)
const layer10km = L.layerGroup();
// ... (hier kannst du deine anderen Lauf-Layer so laden wie gehabt)


// --- Informationen Layer mit Sublayern ---

const parkingLayer = L.layerGroup();
const oepnvLayer = L.layerGroup();

// Hauptlayer "Informationen" als LayerGroup mit den Sublayern
const infoLayer = L.layerGroup([parkingLayer, oepnvLayer]);

// Funktion für skalierte Marker-Beschriftungen (wie bei Parkplätzen)
function createScaledMarkerLabel(text, baseSize, color = 'black') {
  const zoom = map.getZoom();
  const scale = Math.min(1, Math.max(0.6, (zoom - 12) / 6));
  const size = baseSize * scale;
  return `<div class="marker-label" style="width:${size}px;height:${size}px;font-size:${size*0.45}px;color:${color};border-color:${color};">${text}</div>`;
}

// Parkplätze laden und anzeigen
fetch('parken.geojson')
  .then(res => res.json())
  .then(data => {
    data.features.forEach(feature => {
      if (!feature.geometry || feature.geometry.type !== 'Point') return;
      const coords = feature.geometry.coordinates;
      const latlng = L.latLng(coords[1], coords[0]);
      const infoText = feature.properties.info || feature.properties.adresse || "Parkplatz";

      const parkIcon = () => L.divIcon({
        className: "start-goal-icon",
        iconAnchor: [15,15],
        html: createScaledMarkerLabel("P", 30)
      });

      const marker = L.marker(latlng, { icon: parkIcon() });
      marker.bindTooltip(infoText, { permanent: false, direction: 'top' });
      parkingLayer.addLayer(marker);

      // Zoom anpassen
      map.on('zoomend', () => marker.setIcon(parkIcon()));
    });
  })
  .catch(err => console.error("Fehler beim Laden der parken.geojson:", err));

// ÖPNV laden und anzeigen (ÖPNV als Punkte mit "H" Marker)
fetch('oepnv.geojson')
  .then(res => res.json())
  .then(data => {
    data.features.forEach(feature => {
      if (!feature.geometry || feature.geometry.type !== 'Point') return;
      const coords = feature.geometry.coordinates;
      const latlng = L.latLng(coords[1], coords[0]);
      const infoText = feature.properties.info || "ÖPNV Haltestelle";

      // H-Symbol mit Skalierung wie Parkplätze
      const hIcon = () => L.divIcon({
        className: "start-goal-icon",
        iconAnchor: [15,15],
        html: createScaledMarkerLabel("H", 30, 'darkblue')
      });

      const marker = L.marker(latlng, { icon: hIcon() });
      marker.bindTooltip(infoText, { permanent: false, direction: 'top' });
      oepnvLayer.addLayer(marker);

      map.on('zoomend', () => marker.setIcon(hIcon()));
    });
  })
  .catch(err => console.error("Fehler beim Laden der oepnv.geojson:", err));


// --- Layer Control mit verschachtelten Layern ---

const baseLayers = {
  "10 km DM und Citylauf (2 Runden)": layer10km,
  // ... hier weitere Basis-Layer nach Bedarf hinzufügen
};

const overlays = {
  "Informationen": infoLayer,
  "  ├ Parkplätze": parkingLayer,
  "  └ ÖPNV": oepnvLayer
};

L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);

// Sichtbarkeit steuern: Sublayer nur sichtbar, wenn infoLayer an ist

function updateSublayerVisibility() {
  if (!map.hasLayer(infoLayer)) {
    if (map.hasLayer(parkingLayer)) map.removeLayer(parkingLayer);
    if (map.hasLayer(oepnvLayer)) map.removeLayer(oepnvLayer);
  }
}

map.on('overlayadd', function(e) {
  if (e.name === "Informationen") {
    // infoLayer an: Sublayer ggf. wieder hinzufügen wenn ausgewählt
    if (map.hasLayer(parkingLayer)) map.addLayer(parkingLayer);
    if (map.hasLayer(oepnvLayer)) map.addLayer(oepnvLayer);
  }
  if ((e.name === "  ├ Parkplätze" || e.name === "  └ ÖPNV") && !map.hasLayer(infoLayer)) {
    // Sublayer an, aber infoLayer aus? Sublayer entfernen
    if (e.name === "  ├ Parkplätze") map.removeLayer(parkingLayer);
    if (e.name === "  └ ÖPNV") map.removeLayer(oepnvLayer);
  }
});

map.on('overlayremove', function(e) {
  if (e.name === "Informationen") {
    // infoLayer aus: Sublayer ausblenden
    updateSublayerVisibility();
  }
  if (e.name === "  ├ Parkplätze") {
    if (map.hasLayer(parkingLayer)) map.removeLayer(parkingLayer);
  }
  if (e.name === "  └ ÖPNV") {
    if (map.hasLayer(oepnvLayer)) map.removeLayer(oepnvLayer);
  }
});

// --- Optionale Start-Layer ---
// infoLayer.addTo(map); // falls "Informationen" standardmäßig an
// layer10km.addTo(map); // falls 10km Standard-Basislayer

</script>
</body>
</html>
